<?php
/**
 * CreditCheckApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Capayable API V2
 *
 * API for Pay after delivery and Pay in 3 installments
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.5
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * CreditCheckApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CreditCheckApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation creditCheckV2Post
     *
     * # Request credit check     You can perform a credit check on a user.If accepted, the order is final and is going to be paid on invoice.Remember to store the TransactionNumber of the response somewhere with the order, you’ll need it for the invoice follow up.                 The credit check counts as registering an order, so it has to be followed up by an invoice or a cancellation.If not, the order will remain open and may block the customer from doing another order with Capayable.                Note: the credit check on the live environment may take a while, so be sure to set longer timeouts (max 2 minutes). .    In the test environment, use the LastName ‘Refuse’ to get a refused response (`IsAccepted` = `false`) with a random refuse reason.    In the production environment IsFinal should always be ‘true’. In your test environment, you can use ‘false’ while building your connection, as it will not actually register an order and therefore allow you to do multiple checks on the same address(and TransactionNumber will be empty).    If three installments is supported please use the new PaymentMethod property to select the correct payment method. The IsInThreeInstallments property is obsolete.    ## Refuse reason     (Ignore if IsAccepted=true)  There are several possible reasons for refusing:  - `AMOUNT_EXCEEDS_LIMIT` = 1 means the order amount is above this limit. Each shop has an order amount limit above which pay after delivery by Capayable is not available.  - `BALANCE_EXCEEDS_LIMIT`= 2 means the order amount plus the balance of unpaid orders by the customer is above this limit. There is a limit on the unpaid sum of all orders with this shops or other shops using Capayable.   -  `NOT_CREDITWORTHY` = 3 means the customer is not accepted for credit by this service.  Capayable uses services for the actual credit check (B2C: Experian, B2B: Graydon).   - `CREDITCHECK_UNAVAILABLE` = 4 means the extern credit check service is not be available.  - `NOT_FOUND` = 5 means the corporation could not be found based on its name and/or its address(B2B only).  - `ADDRESS_BLOCKED` = 6: the invoice address is blocked by Capayable   - `TOO_YOUNG` = 7: the customer is 18-  - `DIFFERENT_SHIPPING_ADDRESS` = 8: for some shops, the shipping address must be the same as the invoice address  - `SHIPPING_ADDRESS_BLOCKED` = 9: the shipping address is blocked by Capayable   - `IP_ADDRESS_BLOCKED` = 10: the IP address is blocked by Capayable   - `COUNTRY_BLOCKED` = 11: the country of the invoice address is blocked by Capayable   - `SHIPPING_COUNTRY_BLOCKED` = 12: the country of the shipping address is blocked by Capayable   - `AMOUNT_TOO_LOW` = 13: the invoice amount is to low. Each shop has a mimimum amount.  - `TOO_MANY_OPEN_INVOICES` = 14: the customer has too still open invoices with Capyable  - `IP_ADDRESS_BLOCKED_MULTIPLE_ORDERS_WITHIN_24HRS` = 15: for some shops, only one order per IP address is allowed in 24 hours.    In all cases the relevant contact info for the customer (or shop) is returned: the name of the company and a phone number.The customer can contact this number if he has questions about the refusal.  Get the translation of the refusereason by adding lang=nl to the querystring in the request.
     *
     * @param  \Swagger\Client\Model\CreditCheckRequestV2Model $model model (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CreditCheckResult
     */
    public function creditCheckV2Post($model)
    {
        list($response) = $this->creditCheckV2PostWithHttpInfo($model);
        return $response;
    }

    /**
     * Operation creditCheckV2PostWithHttpInfo
     *
     * # Request credit check     You can perform a credit check on a user.If accepted, the order is final and is going to be paid on invoice.Remember to store the TransactionNumber of the response somewhere with the order, you’ll need it for the invoice follow up.                 The credit check counts as registering an order, so it has to be followed up by an invoice or a cancellation.If not, the order will remain open and may block the customer from doing another order with Capayable.                Note: the credit check on the live environment may take a while, so be sure to set longer timeouts (max 2 minutes). .    In the test environment, use the LastName ‘Refuse’ to get a refused response (`IsAccepted` = `false`) with a random refuse reason.    In the production environment IsFinal should always be ‘true’. In your test environment, you can use ‘false’ while building your connection, as it will not actually register an order and therefore allow you to do multiple checks on the same address(and TransactionNumber will be empty).    If three installments is supported please use the new PaymentMethod property to select the correct payment method. The IsInThreeInstallments property is obsolete.    ## Refuse reason     (Ignore if IsAccepted=true)  There are several possible reasons for refusing:  - `AMOUNT_EXCEEDS_LIMIT` = 1 means the order amount is above this limit. Each shop has an order amount limit above which pay after delivery by Capayable is not available.  - `BALANCE_EXCEEDS_LIMIT`= 2 means the order amount plus the balance of unpaid orders by the customer is above this limit. There is a limit on the unpaid sum of all orders with this shops or other shops using Capayable.   -  `NOT_CREDITWORTHY` = 3 means the customer is not accepted for credit by this service.  Capayable uses services for the actual credit check (B2C: Experian, B2B: Graydon).   - `CREDITCHECK_UNAVAILABLE` = 4 means the extern credit check service is not be available.  - `NOT_FOUND` = 5 means the corporation could not be found based on its name and/or its address(B2B only).  - `ADDRESS_BLOCKED` = 6: the invoice address is blocked by Capayable   - `TOO_YOUNG` = 7: the customer is 18-  - `DIFFERENT_SHIPPING_ADDRESS` = 8: for some shops, the shipping address must be the same as the invoice address  - `SHIPPING_ADDRESS_BLOCKED` = 9: the shipping address is blocked by Capayable   - `IP_ADDRESS_BLOCKED` = 10: the IP address is blocked by Capayable   - `COUNTRY_BLOCKED` = 11: the country of the invoice address is blocked by Capayable   - `SHIPPING_COUNTRY_BLOCKED` = 12: the country of the shipping address is blocked by Capayable   - `AMOUNT_TOO_LOW` = 13: the invoice amount is to low. Each shop has a mimimum amount.  - `TOO_MANY_OPEN_INVOICES` = 14: the customer has too still open invoices with Capyable  - `IP_ADDRESS_BLOCKED_MULTIPLE_ORDERS_WITHIN_24HRS` = 15: for some shops, only one order per IP address is allowed in 24 hours.    In all cases the relevant contact info for the customer (or shop) is returned: the name of the company and a phone number.The customer can contact this number if he has questions about the refusal.  Get the translation of the refusereason by adding lang=nl to the querystring in the request.
     *
     * @param  \Swagger\Client\Model\CreditCheckRequestV2Model $model (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CreditCheckResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditCheckV2PostWithHttpInfo($model)
    {
        $returnType = '\Swagger\Client\Model\CreditCheckResult';
        $request = $this->creditCheckV2PostRequest($model);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CreditCheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation creditCheckV2PostAsync
     *
     * # Request credit check     You can perform a credit check on a user.If accepted, the order is final and is going to be paid on invoice.Remember to store the TransactionNumber of the response somewhere with the order, you’ll need it for the invoice follow up.                 The credit check counts as registering an order, so it has to be followed up by an invoice or a cancellation.If not, the order will remain open and may block the customer from doing another order with Capayable.                Note: the credit check on the live environment may take a while, so be sure to set longer timeouts (max 2 minutes). .    In the test environment, use the LastName ‘Refuse’ to get a refused response (`IsAccepted` = `false`) with a random refuse reason.    In the production environment IsFinal should always be ‘true’. In your test environment, you can use ‘false’ while building your connection, as it will not actually register an order and therefore allow you to do multiple checks on the same address(and TransactionNumber will be empty).    If three installments is supported please use the new PaymentMethod property to select the correct payment method. The IsInThreeInstallments property is obsolete.    ## Refuse reason     (Ignore if IsAccepted=true)  There are several possible reasons for refusing:  - `AMOUNT_EXCEEDS_LIMIT` = 1 means the order amount is above this limit. Each shop has an order amount limit above which pay after delivery by Capayable is not available.  - `BALANCE_EXCEEDS_LIMIT`= 2 means the order amount plus the balance of unpaid orders by the customer is above this limit. There is a limit on the unpaid sum of all orders with this shops or other shops using Capayable.   -  `NOT_CREDITWORTHY` = 3 means the customer is not accepted for credit by this service.  Capayable uses services for the actual credit check (B2C: Experian, B2B: Graydon).   - `CREDITCHECK_UNAVAILABLE` = 4 means the extern credit check service is not be available.  - `NOT_FOUND` = 5 means the corporation could not be found based on its name and/or its address(B2B only).  - `ADDRESS_BLOCKED` = 6: the invoice address is blocked by Capayable   - `TOO_YOUNG` = 7: the customer is 18-  - `DIFFERENT_SHIPPING_ADDRESS` = 8: for some shops, the shipping address must be the same as the invoice address  - `SHIPPING_ADDRESS_BLOCKED` = 9: the shipping address is blocked by Capayable   - `IP_ADDRESS_BLOCKED` = 10: the IP address is blocked by Capayable   - `COUNTRY_BLOCKED` = 11: the country of the invoice address is blocked by Capayable   - `SHIPPING_COUNTRY_BLOCKED` = 12: the country of the shipping address is blocked by Capayable   - `AMOUNT_TOO_LOW` = 13: the invoice amount is to low. Each shop has a mimimum amount.  - `TOO_MANY_OPEN_INVOICES` = 14: the customer has too still open invoices with Capyable  - `IP_ADDRESS_BLOCKED_MULTIPLE_ORDERS_WITHIN_24HRS` = 15: for some shops, only one order per IP address is allowed in 24 hours.    In all cases the relevant contact info for the customer (or shop) is returned: the name of the company and a phone number.The customer can contact this number if he has questions about the refusal.  Get the translation of the refusereason by adding lang=nl to the querystring in the request.
     *
     * @param  \Swagger\Client\Model\CreditCheckRequestV2Model $model (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditCheckV2PostAsync($model)
    {
        return $this->creditCheckV2PostAsyncWithHttpInfo($model)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditCheckV2PostAsyncWithHttpInfo
     *
     * # Request credit check     You can perform a credit check on a user.If accepted, the order is final and is going to be paid on invoice.Remember to store the TransactionNumber of the response somewhere with the order, you’ll need it for the invoice follow up.                 The credit check counts as registering an order, so it has to be followed up by an invoice or a cancellation.If not, the order will remain open and may block the customer from doing another order with Capayable.                Note: the credit check on the live environment may take a while, so be sure to set longer timeouts (max 2 minutes). .    In the test environment, use the LastName ‘Refuse’ to get a refused response (`IsAccepted` = `false`) with a random refuse reason.    In the production environment IsFinal should always be ‘true’. In your test environment, you can use ‘false’ while building your connection, as it will not actually register an order and therefore allow you to do multiple checks on the same address(and TransactionNumber will be empty).    If three installments is supported please use the new PaymentMethod property to select the correct payment method. The IsInThreeInstallments property is obsolete.    ## Refuse reason     (Ignore if IsAccepted=true)  There are several possible reasons for refusing:  - `AMOUNT_EXCEEDS_LIMIT` = 1 means the order amount is above this limit. Each shop has an order amount limit above which pay after delivery by Capayable is not available.  - `BALANCE_EXCEEDS_LIMIT`= 2 means the order amount plus the balance of unpaid orders by the customer is above this limit. There is a limit on the unpaid sum of all orders with this shops or other shops using Capayable.   -  `NOT_CREDITWORTHY` = 3 means the customer is not accepted for credit by this service.  Capayable uses services for the actual credit check (B2C: Experian, B2B: Graydon).   - `CREDITCHECK_UNAVAILABLE` = 4 means the extern credit check service is not be available.  - `NOT_FOUND` = 5 means the corporation could not be found based on its name and/or its address(B2B only).  - `ADDRESS_BLOCKED` = 6: the invoice address is blocked by Capayable   - `TOO_YOUNG` = 7: the customer is 18-  - `DIFFERENT_SHIPPING_ADDRESS` = 8: for some shops, the shipping address must be the same as the invoice address  - `SHIPPING_ADDRESS_BLOCKED` = 9: the shipping address is blocked by Capayable   - `IP_ADDRESS_BLOCKED` = 10: the IP address is blocked by Capayable   - `COUNTRY_BLOCKED` = 11: the country of the invoice address is blocked by Capayable   - `SHIPPING_COUNTRY_BLOCKED` = 12: the country of the shipping address is blocked by Capayable   - `AMOUNT_TOO_LOW` = 13: the invoice amount is to low. Each shop has a mimimum amount.  - `TOO_MANY_OPEN_INVOICES` = 14: the customer has too still open invoices with Capyable  - `IP_ADDRESS_BLOCKED_MULTIPLE_ORDERS_WITHIN_24HRS` = 15: for some shops, only one order per IP address is allowed in 24 hours.    In all cases the relevant contact info for the customer (or shop) is returned: the name of the company and a phone number.The customer can contact this number if he has questions about the refusal.  Get the translation of the refusereason by adding lang=nl to the querystring in the request.
     *
     * @param  \Swagger\Client\Model\CreditCheckRequestV2Model $model (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditCheckV2PostAsyncWithHttpInfo($model)
    {
        $returnType = '\Swagger\Client\Model\CreditCheckResult';
        $request = $this->creditCheckV2PostRequest($model);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditCheckV2Post'
     *
     * @param  \Swagger\Client\Model\CreditCheckRequestV2Model $model (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditCheckV2PostRequest($model)
    {
        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling creditCheckV2Post'
            );
        }

        $resourcePath = '/v2/creditcheck';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($model)) {
            $_tempBody = $model;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/xml'],
                ['application/json', 'text/json', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $headers['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
